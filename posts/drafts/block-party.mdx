---
title: "Block Party: The Past, Present, and Future of Block-based Editors"
description: "The rise of interactive, editable blocks as the basic unit of documents on the web"
updated: "2022-06-22"
startDate: "2022-06-22"
type: "essay"
cover: "/images/covers/databases-cover@2x.png"
topics: ["Design", "The Web"]
featured: true
growthStage: "seedling"
---

<Disclaimer>

This essay has nothing to do with the blockchain or the Web3 movement and will not be available for purchase as an NFT. It's not that kind of block.

</Disclaimer>

<AssumedAudience>

People who design and build websites, apps, and interfaces. Likely ones related to the fields of “tools for thought”, knowledge management, and collaborative work.

</AssumedAudience>

<Spacer size="small" />

<IntroParagraph>

Over the last five years, our digital documents and pages have taken on a strange shape. They have become noticeably _blocky_.

</IntroParagraph>

The **block** — a rectangular section of a document that looks and acts a certain way, depending on its type — is our new hot interface pattern<Footnote idName={1}>Take “new” lightly here. The concept of blocks is an exceptionally old idea in software design, but we will cover that ground later.</Footnote>. The way swipeable cards were all the rage in 2014.

You have almost certainly seen and used these blocks. They come in an array of familiar types; ranging from simple formats like headers and blockquotes, to complex interactive widgets like tables and embeds.

<TwoColumn maxWidth="1100px" gridGap="2rem" alignItems="start">

<DemoBlock1 />
<DemoBlock2 />

</TwoColumn>

<TwoColumn maxWidth="1100px" gridGap="2rem" alignItems="start">

<DemoBlock3 />
<DemoBlock4 />

</TwoColumn>

<Spacer size="small" />

These blocks don't look drastically different to what you see on the web every day. Except normal, everyday users can **create**, **edit**, and **publish** them to the web without touching any HTML, CSS, or JS. <Footnote idName={2}>At a lower level these blocks are of course built with core web technologies, but at the level of the user interface people don't need to touch code.</Footnote> They are a syntax-free, user-friendly way to create dynamic, complex documents, sites, and even apps on the web.

The places where we create these blocks have been christened _block-based editors_. And they fall into three major categories:

<ListNumber number="1" title="Personal and collaborative documents">

Document editors, team wikis, and personal note-taking systems were the first category to get on board with blocks. The most popular examples here include [Notion](https://www.notion.so/), [Coda](https://coda.io/), [Google
Docs](https://docs.google.com/), and [Almanac](https://almanac.io/)

</ListNumber>

<ListNumber number="2" title="“No-code” website builders">

Platforms that help people create blog posts and simple webpages. [Wordpress Gutenberg](https://wordpress.org/gutenberg/), [Squarespace](https://www.squarespace.com/), and [Webflow](https://webflow.com/)

</ListNumber>

<ListNumber number="3" title="Do-it-yourself SaaS application builders">

Platforms that give small teams and companies the flexibilty to create their own dynamic views of data and perform basic actions. Newer apps like [Retool](https://retool.com/), [Glide](https://www.glideapps.com/), [ClickUp](https://clickup.com/), and [Fibery](https://fibery.io/) fit into this space.

</ListNumber>

We're now in the middle of a Cambrian explosion of these editors. Blocks are a core concept in almost every modern document editor and no-code website builder. In addition to those mentioned above there's also [Craft](https://www.craft.do/), [Clover](https://cloverapp.co/), [Microsoft Loop](https://www.microsoft.com/en-us/microsoft-loop?ms.url=microsoftcommicrosoft-loop), [Kosmik](https://www.kosmik.app/), [Roam Research](https://roamresearch.com/), [Logseq](https://logseq.com/), [Remnote](https://www.remnote.com/), [Thunknotes](https://www.thunknotes.com/), [Clarity](https://www.clarity.so/), [Fermat](https://fermat.ws/), [Muse](https://museapp.com/), [Reflect](https://reflect.app/), [Mem](https://get.mem.ai/), [Athens](https://www.athensresearch.org/), the list goes on.

<BasicImage
  width="960px"
  src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:good,w_1200/v1649596679/maggieappleton.com/essays/block-editors/BlockLogos_cktabl.png"
  alt="A grid of logos of popular block-based editors"
  margin="0 auto 1rem"
/>

At last count I found 30 block-editors in active development, and I've certainly missed some. Two more will get seed funding while you're reading this.

Given this popular burst, it's a fine time to ask some clarifying questions:

- What _exactly_ is a “block”?
- Why are blocks such a popular and widely used interface pattern?
- What common standards and best practices are we congregating around for how blocks work?
- What historical threads led us to block-based interfaces?
- What new possibilities do blocks enable for both developers and end-users?

We'll attempt to answer all these questions in this piece. We'll start with a quick tour through the popular interface patterns being used in these editors. We'll then consider what block-based editors allow us to do that classical text-centric editors can't. We'll explore what historical interface traditions and infrastructure made our block-filled present possible. And then finally chuck around some irresponsibly speculative ideas on how the block landscape might evolve in the coming years.

## The Conventional Patterns of Block-Editors

At the moment we don't have a strict definition of what counts as a _block-based editor_, but our current ones all follow an impressively consistent set of interface patterns:

<div style={{display: "inline-block"}}>
<svg
aria-labelledby="titleID"
  width="120"
  height="120"
  viewBox="0 0 142 142"
  fill="none"
  style={{ float: "left", display: "inline-block", marginRight: "1.25rem", top: "0.5rem", position: "relative" }}
  xmlns="http://www.w3.org/2000/svg"
>
<title id="titleID">Pattern #1</title>
  <rect width="142" height="142" fill="white" />
  <path
    d="M88.31 112.39V112.17C83.47 106.12 82.37 102.82 82.37 94.57V30H80.83C72.69 38.03 63.23 43.53 53 47.93V49.69H62.68V94.57C62.68 102.71 61.69 106.12 56.85 112.17V112.39H88.31Z"
    fill="#04A5BB"
  />
  <rect
    x="7"
    y="7"
    width="128"
    height="128"
    stroke="#04A5BB"
    stroke-width="2"
  />
</svg>

<h3 style={{ margin: "0.25rem 0 0.5rem" }}>Blocks are first-class citizens</h3>

Documents made with blocks look suspiciously similar to traditional documents, but
are built around a different conceptual model. Rather than treating documents as
strings and paragraphs of styled text, these editors treat them as a stack of types
blocks:

 </div>

<FullWidthSection width="1100px">

<TextvBlocks />

</FullWidthSection>

It's a mindset shift from a text-first environment to a block-first environment.

In classic documents where text is the default format, you can sometimes add special elements like images or tables, but they're treated as exceptions. In block-editors, we don't treat text any differently to an image or table – it's just another block. Blocks are the primary unit of composition, not individual lines of text.

<div style={{display: "inline-block", marginTop: "3rem"}}>

<svg
  aria-labelledby="titleID"
  width="120"
  height="120"
  viewBox="0 0 142 142"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
  style={{
    float: "left",
    display: "inline-block",
    marginRight: "1.25rem",
    top: "0.5rem",
    position: "relative",
  }}
>
  <title id="titleID">Pattern #2</title>
  <rect width="142" height="142" fill="white" />
  <rect
    x="7"
    y="7"
    width="128"
    height="128"
    stroke="#04A5BB"
    stroke-width="2"
  />
  <path
    d="M92.81 112.17L100.73 85.44L99.08 84.89C94.68 91.49 87.53 97.21 77.3 97.21H57.72C83.57 79.83 97.21 66.63 97.21 51.67C97.21 39.35 88.08 30 67.4 30C57.83 30 51.56 31.98 47.6 33.52L44.63 55.41L46.39 55.96C52.33 42.98 59.7 33.63 66.85 33.63C73.45 33.63 77.41 40.67 77.41 52.11C77.41 68.39 68.28 84.12 41 110.19V112.17H92.81Z"
    fill="#04A5BB"
  />
</svg>

<h3 style={{ margin: "0.25rem 0 0.5rem" }}>1-click block creation</h3>

All block-based editors allow you to quickly add a block to a document or canvas within 1-2 clicks or keystrokes. Most do this by having users type a hotkey – usually the slash `/` key <Footnote idName={3}> Or rarely @ if an app is feeling particularly spicy and innovative. Sometimes you can also click a floating + icon nearby.</Footnote>. This triggers a “block picker” menu that offers users a set of block choices:

</div>

<ThreeColumn gridGap="0">

<BasicImage
  src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:good,w_600/v1643453676/maggieappleton.com/essays/block-editors/block-ed_slash_4_sj3kqe.png"
  alt="Slash command menu with a list of blocks in Notion"
  margin="0"
/>
<BasicImage
  src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:good,w_600/v1643453676/maggieappleton.com/essays/block-editors/block-ed_slash_5_tfjmxu.png"
  alt="Slash command menu with a list of blocks in Roam Research"
  margin="0"
/>
<BasicImage
  src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:good,w_600/v1643453676/maggieappleton.com/essays/block-editors/block-ed_slash_1_evqqr8.png"
  alt="Slash command menu with a list of blocks in Wordpress Gutenberg"
  margin="0"
/>

<BasicImage
  src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:good,w_600/v1643453676/maggieappleton.com/essays/block-editors/block-ed_slash_3_ivuxvv.png"
  alt="Slash command menu with a list of blocks in Coda"
  margin="0"
/>
<BasicImage
  src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:good,w_600/v1643453676/maggieappleton.com/essays/block-editors/block-ed_slash_2_wwwsd8.png"
  alt="Slash command menu with a list of blocks in Clover"
  margin="0"
/>
<BasicImage
  src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:good,w_1200/v1643453676/maggieappleton.com/essays/block-editors/block-ed_slash_6_ggum0f.png"
  alt="Slash command menu with a list of blocks in Wordpress Almanac"
  margin="0"
/>

</ThreeColumn>

You click on the block type you want and it appears inline. You can then add content to the block, or continue adding blocks below.

This interaction pattern allows you to very quickly browse and select blocks without moving your hands off the keyboard. It helps keep you in the flow of writing like a traditional text editor would. Only with a far greater range of mediums and formatting options available at your fingertips.

Some of these applications that have a larger range of blocks have opted to put them in a persistent sidebar. This gives users a way to browse available blocks in a larger area.

<div style={{display: "inline-block", marginTop: "3rem"}}>

<svg
  aria-labelledby="titleID"
  width="120"
  height="120"
  viewBox="0 0 142 142"
  style={{
    float: "left",
    display: "inline-block",
    marginRight: "1.25rem",
    top: "0.5rem",
    position: "relative",
  }}
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <title id="titleID">Pattern #3</title>
  <rect width="142" height="142" fill="white" />
  <rect
    x="7"
    y="7"
    width="128"
    height="128"
    stroke="#04A5BB"
    stroke-width="2"
  />
  <path
    d="M100.41 86.1C100.41 68.39 84.68 60.69 70.38 60.69C67.85 60.69 65.54 60.91 63.45 61.35L99.53 31.76V30H51.79L45.3 44.96H78.08L50.25 67.84L51.79 69.82C55.42 67.29 59.71 65.2 65.21 65.2C74.89 65.2 80.72 72.02 80.72 86.21C80.72 99.52 75.33 108.54 66.09 108.54C57.07 108.54 51.79 99.41 43.76 86.1L42 86.54L44.86 107.33C49.48 110.08 58.17 112.17 67.19 112.17C86.88 112.17 100.41 102.38 100.41 86.1Z"
    fill="#04A5BB"
  />
</svg>

<h3 style={{ margin: "0.25rem 0 0.5rem" }}>
  Each block has a unique, pre-formatted type
</h3>

Every block has a “type” – a specific format that determines what kind of content it will accept (some text, a set of numbers, an image, etc.), how it displays that data, and how the user can interact with it.

This follows what’s known as the [Model View Controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) (MVC) pattern in programming. Each block has a model (its content or data), a view (how it presents that data), and a set of controls. In other words, it's a self-contained MVC component.

{diagram}

When you create a new block, the default interface elements and input fields usually make it clear what kind of content you can enter.

</div>

Checklist blocks let you type in text, tap the checkbox to items as done, assign people to tasks, and add due dates.

<ImageFrame
  src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:best,w_1200/v1645048968/maggieappleton.com/essays/block-editors/Checklist_gadznt.png"
  alt="A set of three different checklists in block-editor apps"
  width="800px"
  margin="0 auto 3rem"
/>

Image blocks let you upload files, embed images via URL, or search through popular creative commons libraries like Unsplash.

<ImageFrame
  src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:best,w_1200/v1645048968/maggieappleton.com/essays/block-editors/Images_hpreeg.png"
  alt="A set of three different image inputs in block-editor apps"
  width="800px"
  margin="0 auto 3rem"
/>

Table blocks let you arrange data in spreadsheets where you can name columns, add extra rows, and sort and filter values.

<ImageFrame
  src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:best,w_1200/v1645048968/maggieappleton.com/essays/block-editors/Table_mfyqtj.png"
  alt="A set of three different tables in block-editor apps"
  width="800px"
  margin="0 auto 3rem"
/>

Each editor has their own set of block types they offer. While there’s no universally agreed upon list, there’s a set of basics that appear almost everywhere: text, header, checklist, bullet list, numbered list, image, video, callout, table, blockquote, embed, code block, divider, and file upload.

Beyond those essentials, its open game. Some editors distinguish themselves by offering a wider array of blocks with advanced functionality. These become competitive advantages in an increasingly monoblock landscape. While others pride themselves on simplicity; trying to stay loyal to simple text-editing traditions.

There seems to be no ceiling to the complexity level we're willing to wrap up into a single block. Some could be standalone apps in their own right. Kanban boards, image galleries, live coding environments, and fully decked-out spreadsheets that function as relational databases can all be encapsulated into a “block”. This extends to embeds which allow users to stick the whole of Google Maps, Figma, or Airtable into a document.

<img width="" src="https://via.placeholder.com/600x300" alt="" />

{spectrum of simple to complex blocks}

<div style={{display: "inline-block", marginTop: "3rem"}}>

<svg
  aria-labelledby="titleID"
  width="120"
  height="120"
  viewBox="0 0 142 142"
  style={{
    float: "left",
    display: "inline-block",
    marginRight: "1.25rem",
    top: "0.5rem",
    position: "relative",
  }}
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <title id="titleID">Pattern #4</title>
  <rect width="142" height="142" fill="white" />
  <rect
    x="7"
    y="7"
    width="128"
    height="128"
    stroke="#04A5BB"
    stroke-width="2"
  />
  <path
    d="M67.93 111.52H96.97V111.3C93.34 105.47 92.57 102.28 92.57 94.36V90.62H102.25L103.46 86.44H92.57V65.54H72.33V86.44H44.61L97.85 31H74.64L39 88.64V90.62H72.33V94.36C72.33 102.17 71.56 105.47 67.93 111.3V111.52Z"
    fill="#04A5BB"
  />
</svg>

<h3 style={{ margin: "0.25rem 0 0.5rem" }}>Directly manipulation of blocks</h3>

If you want to change a block, you click just to the left, or you click directly
on it to drag and drop it into a new position. You are directly touching the thing
you want to change, rather than typing instructions describing the thing you want
to change into a command line.

Blocks are easy to copy, paste, and duplicate. Using
direct manipulation you can drag and drop them into new positions, making it quick
to restructure a document without faffing about with precise text selection.

</div>

{visual for drag and drop}

<div style={{display: "inline-block", marginTop: "3rem"}}>

<svg
  aria-labelledby="titleID"
  width="120"
  height="120"
  style={{
    float: "left",
    display: "inline-block",
    marginRight: "1.25rem",
    top: "0.5rem",
    position: "relative",
  }}
  viewBox="0 0 142 142"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <title id="titleID">Pattern #5</title>
  <rect width="142" height="142" fill="white" />
  <rect
    x="7"
    y="7"
    width="128"
    height="128"
    stroke="#04A5BB"
    stroke-width="2"
  />
  <path
    d="M65.44 112.17C81.06 112.17 98.22 104.03 98.22 85C98.22 67.18 83.15 59.15 67.53 59.15C62.14 59.15 56.86 60.14 52.46 62.34L55.43 44.96H94.15L96.9 30H53.89L47.84 66.63L49.38 67.73C53.78 64.76 57.85 63.77 62.14 63.77C73.69 63.77 78.97 71.36 78.97 85.77C78.97 100.18 73.58 108.54 65.88 108.54C57.74 108.54 51.58 97.98 44.76 86.21L43 86.65L45.75 107.33C49.71 109.75 56.64 112.17 65.44 112.17Z"
    fill="#04A5BB"
  />
</svg>

<h3 style={{ margin: "0.25rem 0 0.5rem" }}>
  Seperation of data and formatting
</h3>

The content a block holds and the way it displays that data isn't firmly tied together. This makes blocks interchangeable.

</div>

{diagram of content and view being separated}

If you decide you want a different block, you can easily swap it out. The content adapts to fit its new format. Data and display aren't tied to one another in block land. You can flexibly play with multiple ways to show the same data.

Checklists can become blockquotes. Headers can become collapsible toggles. Tables can become kanban boards. <Footnote idName={4}>There are of course sensible limitations to this. Most applications won't let you turn an image into a code block or a video block.</Footnote>

{visual for swapping blocks}

<div style={{display: "inline-block", marginTop: "3rem"}}>

<svg
  aria-labelledby="titleID"
  width="120"
  height="120"
  viewBox="0 0 142 142"
  style={{
    float: "left",
    display: "inline-block",
    marginRight: "1.25rem",
    top: "0.5rem",
    position: "relative",
  }}
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <title id="titleID">Pattern #6</title>
  <rect width="142" height="142" fill="white" />
  <rect
    x="7"
    y="7"
    width="128"
    height="128"
    stroke="#04A5BB"
    stroke-width="2"
  />
  <path
    d="M89.38 30.87L88.83 29C49.89 38.13 39 62.33 39 79.82C39 98.08 50.99 112.82 70.35 112.82C87.62 112.82 102.14 101.16 102.14 83.67C102.14 67.39 90.81 57.71 77.17 57.71C68.15 57.71 62.98 62.11 60.56 66.84C63.64 52.1 71.67 37.14 89.38 30.87ZM58.91 82.79C58.91 79.6 59.13 76.19 59.57 72.67C61.66 66.95 66.06 64.42 70.68 64.42C77.83 64.42 82.23 70.25 82.23 85.87C82.23 100.94 78.27 109.19 71.01 109.19C62.21 109.19 58.91 97.09 58.91 82.79Z"
    fill="#04A5BB"
  />
</svg>

<h3 style={{ margin: "0.25rem 0 0.5rem" }}>
  Data can be shared between blocks
</h3>

The content we put into a block isn't necessarily constrained to that block. In some of the more advanced block-editors, blocks can reference data held inside other blocks.

</div>

Blocks are an interface element that allows users to input complex data. They would be fairly limited if that data was contained to a single block.

One of the features that makes our current block-based editors exceptionally powerful is being able to query and reference data held in other blocks.

Notion's “database"-type blocks are one of its most popular features.

Coda is pushing hard in the direction of complex, programmatic systems presented in blocks

Hardcore editors hook their blocks up to robust data structures on the backend, making it possible to relate blocks to one another through connections, referencing, and programmatic logic.

For example, Roam allows you to embed blocks inside one another and see the backlinks between them. Coda takes this a step further and turns blocks into a simple interface for a full programmatic environment.

---

Like all good software designers, the people creating these new editors are following [Jakob's Law](https://www.nngroup.com/videos/jakobs-law-internet-ux/) of internet user experience; people spend 99% of their time on websites _other than yours_. You'll make their lives far easier if you use design patterns they're already familiar with. While many will grumble the similarities between block-editors speaks to a lack of “innovation”, <Footnote idName={3}> “Innovate” | ˈɪnəveɪt | verb. To flagrantly disregard previous historical work and established conventions that have survived the test of time. Results may vary. </Footnote> the industry converging around a set of standards is a net gain for both users and creators.

## What _exactly_ is a block?

We've now seen the general shape and interface patterns of blocks, but what _precisely_ defines a block?

We all love a good definitional debate, and I am not one to rob us of this opportunity. I offered a concise definition above: “A block is a rectangular section of your document that looks and acts a certain way, depending on its type."

I think it's pretty good summary of the situation, but one that leaks in a hundred ways. According to this, the navigation bar, the block-selector dropdown menu, and obnoxious chat widget that won't stop audibly alerting you to a message from a bot could all be mistaken for blocks.

Let's try again, wearing our technological pedant hat: <Footnote idName={5}>This is a good faith best effort, which I'm certainly open to revising if and when more intelligent and experienced people point out its flaws on Twitter. At least be polite when you do :)</Footnote>

<SimpleCard alignLeft>

A block is the basic semantic unit of a block-based interface. It is one of many blocks that can be flexibly arranged and interlinked within a document or canvas.
Each block is:

- connected to a specific set of data
- has a unique type that determines how it displays that data
- includes a set of interactive controls that allow users to edit and manipulate that data

</SimpleCard>

#### What Blocks are Not

To reduce any confusion, let's also make clear what blocks are _not_. Within the context of this essay, blocks do not refer to:

- An entry on a blockchain ledger, or anything to do with Web3 blockchain hype. Please take that party elsewhere.
- A specific technical implementation; they are not the same as React components, Web Components, or software components. They are a conceptual idea about how we present editable content to end-users of the web.

{cartoon sketch of a block as a higher interface concept, possibly implemented in WC/React/etc, but not concerned with implementation. And nothing to do with the blockchain}

The blocks I am talking about here are an interface pattern. How that pattern is implemented is beyond the scope of this article and my limited knowledge as a pseudo-engineer. I'm interested in blocks from a user and interface designer perspective, rather than a web infrastructure perspective. <Footnote idName={6}>There is plenty to be said about the technical challenges of how we could/should build interoperable blocks built on solid web standards, but I'll leave that to someone else. Perhaps you?</Footnote>

## The Benefits of Blocks

As with every shiny new interface pattern, we should question it. Even if the benefits of blocks seem obvious on the surface, it's worth asking what ways of working blocks have made possible. And what ways of working they've made harder or entirely impossible.

Block-based editors are changing the way people create documents, websites, and apps on the web

### Blogging Before Blocks

Before they came along, creating a website or blog post of _the same level of complexity_ available in block editors would have required writing HTML, CSS, and JS by hand.

#### Blocks as end-user programming for the web

It is unsurprising the standard list of block types maps fairly tightly to the [basic text tags](https://developer.mozilla.org/en-US/docs/Web/HTML/Element#text_content) in HTML; `<h1>`, `<img>`, `<ul>`, `<blockquote>`, etc. The web was originally designed as a medium to author and share academic documents, and these basic primitives are still serving us well.

We might be tempted to think blocks are just a way to reuse pre-made snippets of HTML with a GUI stuck on top. This could be true for very basic blocks that simply format text. But many blocks offered by these editors included advanced functionality like uploading files, running calculations, external data integrations, state management, dynamic views, and the ability to filter, sort, and search for data.

We're so used to having access to this type of advanced formatting and functionality on the web we barely think twice about it.

But before these block-editors showed up you would need to know a non-trivial amount of HTML, CSS, and JavaScript if you wanted to add something this complex to a document on the web.

Figuring out how to stick some text in a `<p>` tag is one thing, but building a dynamic table with sorting and filtering is way beyond the programming capabilities of most of us. Blocks provide a user-friendly interface for creating rich, complex web components that previously only developers has access to. They shift power – even if only slightly – from developers to end users.

Even document editors that aren't _officially_ webpage creators end up inadvertendly playing the role. Notion is designed as a wiki for teams, but so many people have reappropriated it as a platform for building personal websites, whole side industries have emerged to support it.

### Documents Before Blocks

Before these atomic, interactive blocks started appearing, our documents were predominately made up of simple text. A linear string of characters, spaces, and new lines breaks were the basic units of any digital document.

<FullWidthSection width="1000px">

<LinearChars />

</FullWidthSection>

String enough of these lines together, and you have a document.

Simple text didn't stay simple for long. Starting in the 1980's, we added on _rich text editing_ – text marked up with formatting like **bold**, _italics_, ~~strikethroughs~~, <u>underlines</u>, <mark>highlights</mark> and the like. Souped up text editors dave us even more formatting options like making the <br /><span style={{ fontSize: "2rem" }}>font size huge <span style={{ color: "#DB552C" }}>and orange</span></span> <img src="https://res.cloudinary.com/dxj9qr5gj/image/upload/c_scale,f_auto,q_auto:good,w_1200/v1643619446/maggieappleton.com/essays/block-editors/wordart_1_qtghbu.png" alt="The words 'and 3D' styled in a giant, orange 3D text effect" style={{ display: "inline-block", margin: "0", width: "220px", position: "relative", top: "30px", marginTop: "-25px" }} />

<Spacer size="small" />

These presentational annotations certainly add semantic meaning – big, orange, 3D text is clearly important.

But the formatting options available to us in classic rich text editing only manipulate the visual style of a set of characters. They rarely add meaningful semantic or functional structure to the document that the computer can understand.

Blocks, on the other hand, combine visual formatting with semantic structure. A Header block is significant both visually and as a type the computer understands.

In the case of documents in wikis and notes, we simply couldn't have created docs as complex with our previous tools.

### What do blocks give us that linear text can't?

On the surface level, a page of linear text and a page of blocks seem identical. But _structurally_ and _functionally_ they are entirely different beasts.

{description of how block-based documents are different to rich text editors}

- Stylistic edits vs structural edits
- Granular character level editing vs block-level editing
- Documents as basic unit of linking, reference, and comments vs block as basic unit
- Flexibility of drag and drop rearrangement; importance of rapid rearrangement
- Swapping block types without changing the content; able to easily view the same data multiple ways
- Interactive and reactive documents; dynamic data on a page you can see in multiple ways, transform, and edit.

All of these presentational annotations expand what we're able to express and communicate through the medium of digital documents. But they're mostly surface level. Stylistic annotations change the visual display of our information, without applying any structural changes to the data. When we make text big and orange, the programme does not encode that as “this text is important” or “this text is a headline.” It has no semantic structure.

Formatting at the character level gives us an enormous amount of granular control – enough to hang ourselves with.

Classical documents might format at the character level, but they organise at the document level. The document is the entity you reference when you link to your work or reference it by name.

A block can be dragged and dropped into a new position on the page. It can be swapped for another type of block without changing its content. It can be copied and pasted into a different document without losing its content and structure.

<img width="" src="https://via.placeholder.com/600x300" alt="" />

{annotated diagram of swapping blocks and dragging and dropping blocks}

Blocks open up a world of flexibility and interactive power within a scoped area. They're easier to move around – a key quality for anyone working with ideas who needs to arrange and rearrange information in relationships to find the right groupings and sequences – which is to say, all of us doing knowledge work.

---

## A History of Blocks

If I asked you to guess when blocks and block-based editors first appeared, I'd expect the audience to split into two camps with very different time scales:

<Blocktimeline />

To prove this point, I ran a quick Twitter poll to gauge the level of historical awareness around block-editors within a small audience of fairly well-informed programmers and interface nerds <Footnote idName={8}>I don't have hard stats on the demographics of my twitter followers, but I'd summarise the group as web developers, tools for thought enthusiasts, and interface designers. In that order.</Footnote>:

<TweetEmbed tweetId="1486694395583901709" />

Let's first acknowledge the fundamental flaws in my poll; it offers my predicted answers by default, and requires people go to the effort of replying if they have an alternate view.

The question itself was also duplicitous. Trying to pinpoint a single “invention moment” by one person or project in history is a fool's errand. Especially in the field of interface design where every new creation is a bric-a-brac recompilation of existing conventions and standards.

But we all make compromises to run reductive, ad-hoc twitter polls.

There were plenty of write-in replies that included [Hypercard](https://en.wikipedia.org/wiki/HyperCard), Douglas Engelbart's [NLS System](<https://en.wikipedia.org/wiki/NLS_(computer_system)>), [Ted Nelson](https://en.wikipedia.org/wiki/Ted_Nelson), and the [Pygmalion](http://acypher.com/wwid/Chapters/01Pygmalion.html) visual programming language. All of whom I'd agree played a role in the development of block-based interfaces. Many of them described or implemented software patterns that could easily be interpreted as block-like. We'll take a closer look at these in a minute.

I wasn't surprised to find most people attribute the interface pattern to Notion. Notion was certainly not the first or last block editor, but it's easily the most visible and widely used to date. Its predecessors are not immediately obvious, and do a poor job of self-promotion.

This is compounded by the fact the web development and design industry is reasonably oblivious to historical precedent. This isn't out of laziness or ambivalence. We're not an industry with well-established intellectual centres, academic legacies, or official degrees yet. None of us were required to take Web History 101 before FTP-ing up our weird Flash sites.

Many of the people who _do_ have holistic, comprehensive understandings of computing and interface design history belong to 🤑 elite 🤑 institutions, and spend their time teaching a small handful of 🤑 elite 🤑 students and writing academic PDFs to one another. I don't see many openly teaching online, speaking at mainstream conferences, or writing in accessible public formats for a wide audience. Our industry's historical ignorance isn't a wild mystery. But I digress.

To make sense of this historical trajectory, I've split the evolution of blocks into three distinct ages:

<FullWidthSection width="960px">

<BlockAges />

</FullWidthSection>

Each of these time frames saw a surge in projects that explored the qualities that led to block-based interfaces. These early efforts addressed pragmatic issues like ecosystem integration, UX usability, and hardware capacity.

### The First Age of Blocks – Xanadu and NLS

<h5 style={{ marginTop: "-0.6rem" }}>1965-1968</h5>

Frankly, the history of any modern interface pattern has to start in California in the late 1960s with the work of Ted Nelson and Douglas Engelbart. The interface waters we currently swim in — graphical screens, click-and-point interactions, hyperlinks, and direct manipulation — all lead back to this same river.

To lightly set the scene, in the 1960s “computers” were giant, hulking, room-sized machines that only large, wealthy corporations and governments owned to run complex statistical and scientific calculations. The idea an individual person might own a computer was ludicrous. What could they possibly need it for?

It took a few rogue thinkers (and a few good drugs) to look at these industrial-size calculators and see something else entirely; the potential for personal devices that could augment the way people think, communicate, and create.

Ted Nelson was not a programmer, but a writer, film maker, and sociologist. He saw the early graphical interfaces engineers were hooking up to computers and imagined ways they might help him write screenplays and edit films.

Throughout the early 1960s he wrote a series of papers proposing a hypothetical system for managing text and editing documents on computers.

And as with most things, Ted Nelson said it first. In 1965 Ted Nelson published a paper in the ACM called **[Complex Information Processing](https://dl.acm.org/doi/10.1145/800197.806036): A File Structure for the Complex, the Changing, and the Indeterminate.** Here he coined the term hypertext, and laid out a structure for file management on machines that would influence the way we structure information for many decades.

In 1974 Nelson wrote Computer Lib / Dream Machines, where he laid out elaborate plans for [[Project Xanadu]] – a hypertext system designed for writing “serious electronic literature.”

That system involved documents made up of 'parts', which could be any data type, and could be freely moved around a document. Being able to insert a part into multiple documents, link parts to one another, and easily rearrange parts within a document were all essential to the concept.

{image of xanadu's parts}

While Nelson is infamous for being the first to coin concepts, his projects are also infamous for never manifesting into real software. Xanadu is still a hypothetical proposal. Which makes it difficult to evaluate whether its elaborate architecture was truly feasible.

Working in the same realm as Nelson was Douglas Engelbart. In 1968 Engelbart gave [the mother of all demos]() showcasing a graphical interface, hyperlinks, point and click interactions, and live video conferencing all at once. His NLS - oNLine System – used flexible parts of a document that could be rearranged. This feels tangentially related to the way blocks work now, but still set the precedent for flexible data structures and dynamic documents.

{image of NLS}

These projects are all spiritual predecesors in this story. The interfaces patterns they established moved us closer to thinking in blocks.

### The Second Age of Blocks – Hypercard, Microsoft OLE and Open Doc

<h5 style={{ marginTop: "-0.6rem" }}>1987-1997</h5>

By the late 1980s, the personal computing revolution was in full swing. Boxy white DELL's graced every modern office desk. Families could afford their own Macintosh and a floppy of Oregon Trail. Gates was xxx

The first meaningful project in this period was Hypercard which .

{image of hypercard}

The idea of creating stacks of uniquely typed blocks inside documents first emerged in the early 1990's.

Microsoft developed a system that allowed users to select an “object” created in one Microsoft application and embed it in another. This **Object Linking and Embedding (OLE)** technology meant you could select a set of cells in Microsoft Excel, copy it, and then paste it into a Microsoft Word document. 'Embedding' the Excel object into Word.

{OLE diagram}

In the parlance of the time, these were called “compound documents"

Microsoft's OLE was the first implementation that made block-based documents possible. Despite this big pragmatic leap, they let their imaginations stop short. OLE didn't seem to spur any dreams beyond copying and pasting bits of Microsoft applications into one another.

Apple stepped up with a vision that aimed to compete with OLE, but took the idea to its full potential. OpenDoc was a programme that flipped the concept of how applications worked on its head. It proposed a compound document made up of multiple small applications, things it called “parts” – similar to our modern day blocks, but more ambitious.

{OpenDoc diagram}

the first OpenDoc-based product release was Apple's CyberDog web browser in May 1996. It died along with Hypercard in 1997

If we're just going off the promotional videos, OpenDoc is the clear winner in this popularity contest:

<Video src="https://www.youtube.com/embed/oFJdjk2rq4E" />

There's still a strong contingent of OpenDoc enthusiasts around. Lamenting its death, analysing what went wrong, and waiting for the idea to re-emerge.

<TweetEmbed tweetId="1389236351711731712" />

### The Third Age of Blocks – Gutenberg, Notion, and the Cambrian Explosion

<h5 style={{ marginTop: "-0.6rem" }}>2016-present</h5>

Starting in 2016 we entered the third age of the block.

2016 was a significantly blocky year for two reasons. First, a small company called Notion released version 1.0 of their team wiki application. This first release introduced many of the interface patterns we now think of canonical for block-based editors. Second, a startup called [Elementor](https://elementor.com/) released a plug-in for Wordpress that would end up changing the entire platform.

These are two useful landmarks to pay attention to, but it would be insincere to say blocks weren't already brewing on the web before this point.

From the start of “Web 2.0” in the mid-2000s block-like objects began to appear on our newly invented _web apps_ – websites that allowed users to dynamically interact with the page without refreshing or reloading it.

Tumblr is worth mentioning here.

Tumblr was at the height of its popularity. The web was interactive and Web 2.0 was in full swing. More and more people needed accessible tools to publish content to the web.

Notion released version 2.0 in 2018. In this context, despite being the most visible and widely used block-editor to date, Notion was quite late to the game.
It's undeniable Notion has been the most influential platform championing and pushing the boundaries of block-based editing in recent years.

Wordpress started work on Gutenberg in 2017(?) and released its first version in 2018(?).

Notion's first release in 2018 kicked things into high gear here. While Wordpress Gutenberg has been out for X years, it served a small use case; writing blog posts. Notion reframed the block editor as an everyday tool – a place to write collaborative documents for your team, or even just yourself. It turned it into an editor you live in, rather than a publishing tool for a specific purpose.

It is exceptionally ironic that when Micrososoft announced their new project "Microsoft Loop” in X, it was lambasted across Twitter as a “shameless Notion clone."

These editors are sometimes belittled as “Notion clones", although Notion was not the first or last platform to implement the conceptual model of documents composed of blocks. Nevertheless, it became a touchstone reference point – a software category in its own right. Like _Uber for X_, we now have _Notion, but with Y feature_.

## Block to the Future

We have made it through our blocky past and present. Which brings us to the part everyone clamours for. _But what is the future?_ What is the point of reciting history, if not to try and find patterns that point to what happens next? Let's march forwards with our rear-view mirror in hand.

<Disclaimer>

I used to work at [HASH](https://hash.ai) – a company specifically focused on
expanding the block ecosystem via the [Block
Protocol](https://blockprotocol.org) project. While I've moved on to a new
role, I still support the efforts of the project and believe it's a worthwhile
idea to pursue.
This essay and all the research associated with it is my own personal work and
opinion. I wrote it on my own time, and no one else at HASH was involved in
its creation. Nevertheless, you should take all my predictions and
pro-block enthusiasm with a grain of salt.

</Disclaimer>

### Future patterns

<ListNumber number="1" title="Ontology-backed blocks">

Blocks connected to ontologicals structures.

- Notion's 'databases'
- Palantir
- Fibery

</ListNumber>

<ListNumber number="2" title="Independent block development">

This was the original dream of OpenDoc. The people who build block-editors don't necessarily have to be the same people who build blocks.

Coda's maker marketplace is one of the recent signs we're moving in this direction.

We've already been moving swiftly in this direction in the larger context of front-end web development. Modular components built by a wide variety of other engineers is the name of the game. We all rely upon open collective efforts like MUI, Chakra, Radix, Reach UI, etc.

The same will happen with blocks, which are a simply a very specific type of component – one designed for authoring documents on the web.

A big disclaimer on this one. I lead design at HASH, where one of our projects is the Block Protocol – a standardised way for blocks to communicate with their embedding applications (aka. block-editors)

{ diagram }

I certainly have a vested interest in the block ecosystem diversifying and maturing.

</ListNumber>

<ListNumber number="3" title="Diversifying block types">

</ListNumber>

4. Compound blocks

As blocks become a more standardised interface approach, we should expect to see a wider diversity of block types.

5. Blocks as end-user programming and emergent design tools

The biggest hope I have for blocks is as an entry point into front-end development for people who can't currently code.

Button blocks on Coda and Retool are big indicators of this.

6. Improved open, indie web publishing tooling

Enabling users to write rich content to the independent, open web. Web 2.0 enabled users to write to the web... within limitations. They can only write to “platforms” - FB, twitter. The platform owners control and own the content.

6. The Modular Web

Standing up a whole website has moved far beyond the capacities of most people. Sandboxed environments like Observable and Jupyter notebook give people the ability to write code and execute it without also needing to learn the command line, Webpack, DNS redirects, etc. etc.

The web was born as a text-first medium. Tim Berners Lee designed it to mimic text documents. Specifically, long, linear research documents shared among scientists and academics as pieces of paper. Ever since then we've been negotiating its paper-like qualities.

The text-first, document-based model comes with a lot of design implications. It presumes the document or page is the basic unit of the web. We store our metadata at the level of the page, usually in the `<head>` tag. We link at the page level, rather than at the word, paragraph, or section level. <Footnote idName={1}>This has improved slightly with #header-level links, but the vast majority of links are still to entire pages, not granular lines or sections within a page.</Footnote>

<References>
  <ReferencesLink
    title="Rich text with Sarah 'Slim' Lim"
    href="https://museapp.com/podcast/48-rich-text/"
    author="Metamuse Podcast"
  />
  <ReferencesLink
    title="Designing the OpenDoc Human Interface"
    href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.101.8&rep=rep1&type=pdf"
    author="Dave Curbow and Elizabeth Dykstra-Erickson"
  />
  <ReferencesLink
    title="Why OpenDoc failed, and then failed 3 more times?"
    href="https://instadeq.com/blog/posts/why-opendoc-failed-and-then-failed-3-more-times/"
    author="Instadeq Blog"
  />
</References>
